package writer

import (
	"bytes"
	"context"
	"encoding/binary"
	"fmt"
	pst "github.com/mooijtech/go-pst/v6/pkg"
	"github.com/rotisserie/eris"
	"golang.org/x/sync/errgroup"
	"google.golang.org/protobuf/proto"
	"io"
	"reflect"
	"strconv"
	"strings"
)

// PropertyWriter represents a writer for properties.
type PropertyWriter struct {
	// PropertyWriteChannel represents the Go channel for writing properties.
	PropertyWriteChannel chan *proto.Message
	// PropertyWriteCallbackChannel is called when a property has been written.
	PropertyWriteCallbackChannel chan Property
}

// NewPropertyWriter creates a new PropertyWriter.
func NewPropertyWriter(propertyWriteCallbackChannel chan Property, propertyWriteChannelContext context.Context) (*PropertyWriter, *errgroup.Group, context.Context) {
	propertyWriter := &PropertyWriter{
		PropertyWriteChannel:         make(chan *proto.Message),
		PropertyWriteCallbackChannel: propertyWriteCallbackChannel,
	}

	propertyWriteChannelErrGroup, propertyWriteChannelContext := propertyWriter.StartPropertyWriteChannel(propertyWriteChannelContext)

	return propertyWriter, propertyWriteChannelErrGroup, propertyWriteChannelContext
}

// AddProperties adds the properties to write.
func (propertyWriter *PropertyWriter) AddProperties(properties []*proto.Message) {
	for _, property := range properties {
		propertyWriter.PropertyWriteChannel <- property
	}
}

// StartPropertyWriteChannel starts the Go channel for writing properties.
func (propertyWriter *PropertyWriter) StartPropertyWriteChannel(propertyWriteChannelContext context.Context) (*errgroup.Group, context.Context) {
	propertyWriteChannelErrGroup, propertyWriteChannelContext := errgroup.WithContext(propertyWriteChannelContext)

	propertyWriteChannelErrGroup.Go(func() error {
		for receivedProperties := range propertyWriter.PropertyWriteChannel {
			// Create writable property.
			writableProperties, err := propertyWriter.GetProperties(receivedProperties)

			if err != nil {
				return eris.Wrap(err, "failed to get writable properties")
			}

			// Send writable property to callback.
			if propertyWriter.PropertyWriteCallbackChannel != nil {
				for _, writableProperty := range writableProperties {
					propertyWriter.PropertyWriteCallbackChannel <- writableProperty
				}
			}
		}

		return nil
	})

	return propertyWriteChannelErrGroup, propertyWriteChannelContext
}

// Property represents a property that can be written.
type Property struct {
	ID    pst.Identifier
	Type  pst.PropertyType
	Value bytes.Buffer
}

// WriteTo writes the byte representation of the property.
// Used by the PropertyContextWriter.
func (property *Property) WriteTo(writer io.Writer) (int64, error) {
	// TODO -
	return 0, nil
}

// GetProperties returns the writable properties.
// Uses reflection to convert a proto.Message (properties.Message, properties.Attachment, etc.) to a list of properties.
func (propertyWriter *PropertyWriter) GetProperties(properties *proto.Message) ([]Property, error) {
	var writableProperties []Property

	propertyTypes := reflect.TypeOf(properties).Elem()
	propertyValues := reflect.ValueOf(properties).Elem()

	for i := 0; i < propertyTypes.NumField(); i++ {
		if !propertyTypes.Field(i).IsExported() || propertyValues.Field(i).IsNil() {
			continue
		}

		// Get the struct tag which we use to get the property ID and property type.
		// These struct tags are generated by cmd/properties/generate.go.
		tag := strings.ReplaceAll(propertyTypes.Field(i).Tag.Get("msg"), ",omitempty", "")

		if tag == "" {
			fmt.Printf("Skipping property without tag: %s\n", propertyTypes.Field(i).Name)
			continue
		}

		propertyID, err := strconv.Atoi(strings.Split(tag, "-")[0])

		if err != nil {
			return nil, eris.Wrap(err, "failed to convert propertyID to int")
		}

		propertyType, err := strconv.Atoi(strings.Split(tag, "-")[1])

		if err != nil {
			return nil, eris.Wrap(err, "failed to convert propertyType to int")
		}

		var propertyBuffer bytes.Buffer

		switch propertyValue := propertyValues.Field(i).Elem().Interface().(type) {
		case string:
			// Binary is intended for fixed-size structures with obvious encodings.
			// Strings are not fixed size and do not have an obvious encoding.
			if _, err := io.WriteString(&propertyBuffer, propertyValue); err != nil {
				return nil, eris.Wrap(err, "failed to write string")
			}
		default:
			if err := binary.Write(&propertyBuffer, binary.LittleEndian, propertyValue); err != nil {
				return nil, eris.Wrap(err, "failed to write property")
			}
		}

		writableProperties = append(writableProperties, Property{
			ID:    pst.Identifier(propertyID),
			Type:  pst.PropertyType(propertyType),
			Value: propertyBuffer,
		})
	}

	return writableProperties, nil
}
