package pst

import (
	"bytes"
	"encoding/binary"
	"fmt"
	"github.com/rotisserie/eris"
	"golang.org/x/sync/errgroup"
	"google.golang.org/protobuf/proto"
	"io"
	"reflect"
	"strconv"
	"strings"
)

// PropertyWriter represents a writer for properties.
type PropertyWriter struct {
	// PropertyWriteChannel represents the Go channel for writing properties.
	PropertyWriteChannel chan proto.Message
	// PropertyWriteCallbackChannel is called when a property has been written.
	PropertyWriteCallbackChannel chan Property
}

// NewPropertyWriter creates a new PropertyWriter.
// propertyWriteCallbackChannel is not required.
func NewPropertyWriter(writeGroup *errgroup.Group, propertyWriteCallbackChannel chan Property) *PropertyWriter {
	propertyWriter := &PropertyWriter{
		PropertyWriteChannel:         make(chan proto.Message),
		PropertyWriteCallbackChannel: propertyWriteCallbackChannel,
	}

	// Start the property write channel.
	if propertyWriteCallbackChannel == nil {
		// TODO - Remove this.
		fmt.Printf("Skipping propertyWriteCallbackChannel")
	}

	go propertyWriter.StartPropertyWriteChannel(writeGroup)

	return propertyWriter
}

// AddProperties sends the properties to the write queue.
func (propertyWriter *PropertyWriter) AddProperties(properties ...proto.Message) {
	for _, property := range properties {
		propertyWriter.PropertyWriteChannel <- property
	}
}

// StartPropertyWriteChannel starts the Go channel for writing properties.
func (propertyWriter *PropertyWriter) StartPropertyWriteChannel(writeGroup *errgroup.Group) {
	for receivedProperties := range propertyWriter.PropertyWriteChannel {
		writeGroup.Go(func() error {
			// Create writable byte representation of the property.
			writableProperties, err := propertyWriter.GetProperties(receivedProperties)

			if err != nil {
				return eris.Wrap(err, "failed to get writable properties")
			}

			// Send writable byte representation Property to the callback,
			// in the callback the Property is added to the PropertyContextWriter.
			if propertyWriter.PropertyWriteCallbackChannel != nil {
				for _, writableProperty := range writableProperties {
					propertyWriter.PropertyWriteCallbackChannel <- writableProperty
				}
			}

			return nil
		})
	}
}

// Property represents a property that can be written.
type Property struct {
	ID    Identifier
	Type  PropertyType
	Value bytes.Buffer
}

// WriteTo writes the byte representation of the property.
// Used by the PropertyContextWriter.
func (property *Property) WriteTo(writer io.Writer) (int64, error) {
	// TODO -
	return 0, nil
}

// GetProperties returns the writable properties.
// Uses reflection to convert a proto.Message (properties.Message, properties.Attachment, etc.) to a list of properties.
func (propertyWriter *PropertyWriter) GetProperties(properties proto.Message) ([]Property, error) {
	var writableProperties []Property

	propertyTypes := reflect.TypeOf(properties).Elem()
	propertyValues := reflect.ValueOf(properties).Elem()

	for i := 0; i < propertyTypes.NumField(); i++ {
		if !propertyTypes.Field(i).IsExported() || propertyValues.Field(i).IsNil() {
			continue
		}

		// Get the struct tag which we use to get the property ID and property type.
		// These struct tags are generated by cmd/properties/generate.go.
		tag := strings.ReplaceAll(propertyTypes.Field(i).Tag.Get("msg"), ",omitempty", "")

		if tag == "" {
			fmt.Printf("Skipping property without tag: %s\n", propertyTypes.Field(i).Name)
			continue
		}

		propertyID, err := strconv.Atoi(strings.Split(tag, "-")[0])

		if err != nil {
			return nil, eris.Wrap(err, "failed to convert propertyID to int")
		}

		propertyType, err := strconv.Atoi(strings.Split(tag, "-")[1])

		if err != nil {
			return nil, eris.Wrap(err, "failed to convert propertyType to int")
		}

		var propertyBuffer bytes.Buffer

		switch propertyValue := propertyValues.Field(i).Elem().Interface().(type) {
		case string:
			// Binary is intended for fixed-size structures with obvious encodings.
			// Strings are not fixed size and do not have an obvious encoding.
			if _, err := io.WriteString(&propertyBuffer, propertyValue); err != nil {
				return nil, eris.Wrap(err, "failed to write string")
			}
		default:
			if err := binary.Write(&propertyBuffer, binary.LittleEndian, propertyValue); err != nil {
				return nil, eris.Wrap(err, "failed to write property")
			}
		}

		writableProperties = append(writableProperties, Property{
			ID:    Identifier(propertyID),
			Type:  PropertyType(propertyType),
			Value: propertyBuffer,
		})
	}

	return writableProperties, nil
}
