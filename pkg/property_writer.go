package pst

import (
	"bytes"
	"encoding/binary"
	"fmt"
	"github.com/mooijtech/go-pst/v6/pkg/properties"
	"github.com/rotisserie/eris"
	"github.com/tinylib/msgp/msgp"
	"golang.org/x/sync/errgroup"
	"google.golang.org/protobuf/proto"
	"io"
	"reflect"
	"strconv"
	"strings"
)

// PropertyWriter represents a writer for properties.
// The PropertyContext should be used as a higher structure which manages this PropertyWriter.
type PropertyWriter struct {
	// Writer represents the concurrent writer used while writing.
	Writer io.Writer
	// WriteGroup represents the writers running in Goroutines.
	WriteGroup *errgroup.Group
	// PropertyWriteChannel represents the Go channel for writing properties.
	PropertyWriteChannel chan proto.Message
	// PropertyWriteCallbackChannel is called when a property has been written.
	PropertyWriteCallbackChannel chan Property
	// FormatType represents the FormatType used while writing.
	FormatType FormatType
	// PropertyCount represents the amount of properties this PropertyWriter will write.
	PropertyCount int
}

// NewPropertyWriter creates a new PropertyWriter.
// propertyWriteCallbackChannel is started by the caller.
func NewPropertyWriter(writer io.Writer, writeGroup *errgroup.Group, propertyWriteCallbackChannel chan Property, formatType FormatType) *PropertyWriter {
	propertyWriter := &PropertyWriter{
		Writer:                       writer,
		WriteGroup:                   writeGroup,
		PropertyWriteChannel:         make(chan proto.Message),
		PropertyWriteCallbackChannel: propertyWriteCallbackChannel,
		FormatType:                   formatType,
	}

	// Start the property write channel.
	go propertyWriter.StartPropertyWriteChannel()

	return propertyWriter
}

// Add sends the properties to the write queue, picked up by Goroutines.
// Properties will be written to the PropertyWriteCallbackChannel (see StartPropertyWriteChannel).
func (propertyWriter *PropertyWriter) Add(properties ...proto.Message) {
	for _, property := range properties {
		propertyWriter.PropertyWriteChannel <- property
		propertyWriter.PropertyCount++
	}
}

// StartPropertyWriteChannel starts the Go channel for writing properties.
func (propertyWriter *PropertyWriter) StartPropertyWriteChannel() {
	// The caller is already in a Goroutine.
	for receivedProperties := range propertyWriter.PropertyWriteChannel {
		propertyWriter.WriteGroup.Go(func() error {
			// Create writable byte representation of the properties.
			writableProperties, err := propertyWriter.GetProperties(receivedProperties)

			if err != nil {
				return eris.Wrap(err, "failed to get writable properties")
			}

			// Callback, the PropertyContext handles writing this to the correct place.
			for _, writableProperty := range writableProperties {
				propertyWriter.PropertyWriteCallbackChannel <- writableProperty
			}

			return nil
		})
	}
}

// GetProperties returns the writable properties.
// This code is a hot-path, do not use reflection here.
// Instead, we use code-generated setters thanks to https://github.com/tinylib/msgp (deserialize into structs).
func (propertyWriter *PropertyWriter) GetProperties(protoMessage proto.Message) ([]Property, error) {
	var totalSize int

	totalSize += int(GetIdentifierSize(propertyWriter.FormatType))
	// TODO -

	messagePackBuffer := bytes.NewBuffer(make([]byte, totalSize))
	messagePackWriter := msgp.NewWriterSize(messagePackBuffer, totalSize)

	switch property := protoMessage.(type) {
	case *properties.Message:
		// TODO - Skip nil!
		property.MarshalMsg()
	case *properties.Attachment:

	}

	var properties []Property

	propertyTypes := reflect.TypeOf(protoMessage).Elem()
	propertyValues := reflect.ValueOf(protoMessage).Elem()

	for i := 0; i < propertyTypes.NumField(); i++ {
		if !propertyTypes.Field(i).IsExported() || propertyValues.Field(i).IsNil() {
			continue
		}

		// Get the struct tag which we use to get the property ID and property type.
		// These struct tags are generated by cmd/properties/generate.go.
		tag := strings.ReplaceAll(propertyTypes.Field(i).Tag.Get("msg"), ",omitempty", "")

		if tag == "" {
			fmt.Printf("Skipping property without tag: %s\n", propertyTypes.Field(i).Name)
			continue
		}

		propertyID, err := strconv.Atoi(strings.Split(tag, "-")[0])

		if err != nil {
			return nil, eris.Wrap(err, "failed to convert propertyID to int")
		}

		propertyType, err := strconv.Atoi(strings.Split(tag, "-")[1])

		if err != nil {
			return nil, eris.Wrap(err, "failed to convert propertyType to int")
		}

		var propertyBuffer bytes.Buffer

		switch propertyValue := propertyValues.Field(i).Elem().Interface().(type) {
		case string:
			// Binary is intended for fixed-size structures with obvious encodings.
			// Strings are not fixed size and do not have an obvious encoding.
			if _, err := io.WriteString(&propertyBuffer, propertyValue); err != nil {
				return nil, eris.Wrap(err, "failed to write string")
			}
		default:
			if err := binary.Write(&propertyBuffer, binary.LittleEndian, propertyValue); err != nil {
				return nil, eris.Wrap(err, "failed to write property")
			}
		}

		properties = append(properties, Property{
			Identifier: Identifier(propertyID),
			Type:       PropertyType(propertyType),
			Value:      propertyBuffer,
		})
	}

	return properties, nil
}
